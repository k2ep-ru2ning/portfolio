# 포트폴리오

## 1. 프로젝트

### 1.1 공통 컴포넌트 라이브러리 관리

**소개**

- Tmax WAPL
- 2024.01 - 진행 중
- **TypeScript, React, Vite**
- 협업 도구 내부의 (메신저, 캘린더와 같은) 여러 애플리케이션에서 **공통으로 사용하는 컴포넌트를 제공하는 라이브러리**를 **관리**했습니다.

**성과**

- 라이브러리 빌드 속도 개선

  - **\[상황\]**
    - 오래된 버전의 Rollup을 사용했었고, 설정 파일이 관리 되지 않고 있었습니다.
    - 빌드 속도가 느려서 팀원들이 개발할 때 불편해했습니다.
  - **\[과정\]**
    - 최근 많은 곳에서 안정적으로 사용되고 빠른 속도를 자랑하는 Vite를 도입해, 빌드 속도를 개선하고, 관련 코드도 최신화하기로 했습니다.
    - vite 공식 문서를 참고해 필요한 플러그인들을 설정했습니다. 라이브러리로 빌드하기 위해 필요한 설정도 추가했습니다.
    - Vite로 마이그레이션 하던 도중, 클라이언트 코드에서 타입 추론이 제대로 되지 않는 문제가 발생했습니다. 원인이라고 생각되는 설정을 수정하고 빌드 결과를 확인하면서, 원인을 찾고 문제를 해결했습니다.
  - **\[결과\]**
    - Vite로 마이그레이션 후, 다른 앱에서 라이브러리를 사용했을 때 문제없이 동작했습니다.
    - **빌드 시간이 `63` 초에서 `13` 초로 단축**되어 **팀 개발 생산성이 향상**되었습니다.
  - **\[회고\]**
    - 빌드 도구와 번들러 설정은 막연히 어렵다고 생각했는데, 성공적으로 Vite로 마이그레이션 하면서 자신감을 얻을 수 있었습니다.

- 공통 컴포넌트의 Props Drilling 제거
  - **\[상황\]**
    - 대부분의 공통 컴포넌트가 깊은 depth를 가지고 있어서 Props Drilling이 발생했습니다.
  - **\[해결\]**
    - 상위 컴포넌트에서 Context를 이용해 데이터를 제공하고 하위 컴포넌트는 해당 데이터가 필요하면 가져다 쓰는 형태로 구조를 변경해서, Props Drilling을 제거했습니다.

### 1.2 유저 모임(Room, 룸) 컴포넌트 개발

**소개**

- Tmax WAPL
- 2024.01 - 진행 중
- **TypeScript, React, Vite, MobX, Emotion, MUI, React Hook Form**
- 룸은 (회사에서 개발 중인 협업 도구에서) 유저들의 모임을 의미합니다.
- **서울시교육청**와 **한국농어촌공사**의 협업 도구에 적용했습니다.

#### 1.2.1 룸 리스트 개발

**업무**

- 로그인한 유저가 속한 룸 목록 조회 및 표시 기능 구현
- 룸 이름 기반 검색 기능 구현
- 룸 타입 기반 필터링 기능 구현
- 애플리케이션에 따라 달라지는 메뉴와 버튼을 제공하기 위해, "메신저, 캘린더 앱 프론트엔드 팀"과 소통 및 Props 구조 구상

**성과**

- 룸 리스트 컴포넌트가 **리렌더링 될 때마다 상태가 초기화되는 문제 해결**
  - **\[상황\]**
    - 메신저 앱에서 룸 리스트 컴포넌트를 사용할 때, 간헐적으로 리스트 컴포넌트의 상태가 초기화되는 문제가 발생했습니다.
  - **\[과정 & 결과\]**
    - 최상단에 위치한 룸 리스트 컴포넌트가 렌더링 될 때마다, MobX Store의 인스턴스가 새로 만들어져서 Context로 제공되었기 때문에 발생했습니다.
    - `useState`와 initializer 함수를 함께 쓰거나 `useRef`를 사용해, 리렌더링이 될 때마다 인스턴스가 생성되는 것을 방지해서 문제를 해결했습니다.

#### 1.2.2 룸 생성 다이얼로그 개발

**업무**

- 룸 생성 과정을 Funnel 형태의 컴포넌트로 구현
- 룸 이름, 소개, 해시태그 등의 정보를 입력할 수 있는 프로필 폼 구현
- 룸 타입에 따라 달라지는 생성 흐름 구현
  - 일반 룸 타입 선택 -> 멤버 초대 -> 생성 완료
  - 오픈 룸 타입 선택 -> 프로필 폼 입력 -> 생성 완료
- 룸 생성 흐름 상태 관리를 위해 MobX Store Class 구조 구상
- 생성 과정에서 사용자 입력 상태 관리를 위해 MobX Store Class 구조 구상

**성과**

- **사용자의 입력에 따라 너비가 조절되는 input 컴포넌트 구현** 및 구현 과정에서 **겪은 문제 해결**
  - **\[상황\]**
    - 화면에 표시되지 않는 **span을 이용해 사용자 입력값의 너비를 측정**하고, **input의 너비를 업데이트하는 아이디어**를 사용했습니다.
    - input의 value와 동일한 값을 자식으로 가지고, input과 동일한 스타일을 가지는 span 태그를 사용했습니다.
  - **\[시도 1\]**
    - change 이벤트 핸들러에서 span의 너비를 참조해 input의 너비 상태를 업데이트했습니다. 입력에 따라 input의 너비가 변경되었습니다.
    - 하지만, 사용자의 모든 입력을 표시할 정도로 늘어나지 못해서 **제일 앞 문자 하나가 덜 표시되는 문제가 발생**했습니다.
    - change 이벤트 핸들러가 호출되었을 때, value 상태에 사용자의 마지막 입력이 반영되지 않았습니다. 그래서 이때 span의 너비를 측정하고 input의 너비를 업데이트하면, 입력값 모두를 표시할 수 있는 너비가 아니라 조금 더 작은 너비가 됩니다.
  - **\[시도 2\]**
    - value의 상태가 변경되어 리렌더링 된 후, 마지막 value 값이 반영된 span의 너비를 측정하고 input의 너비를 업데이트하기 위해서 `useEffect`를 활용했습니다.
    - input의 너비가 모든 입력값을 표시할 정도로 늘어났고, 제일 앞 문자 하나가 덜 표시되는 문제도 해결되었습니다.
    - 하지만, **빠르게 입력했을 때 input의 입력값이 깜빡이는 문제**가 발생했습니다.
    - effect 함수에서 input의 상태 업데이트가 완료되기 전에 웹 브라우저가 paint 할 수도 있어서, 빠르게 입력하면 한 단계 늦게 반응해 입력값이 깜빡이는 문제가 발생했습니다.
  - **\[시도 3\]**
    - effect 함수 내부의 상태 변화를 모두 처리하고, 웹 브라우저가 paint 하도록 만들기 위해 `useEffect` 대신, `useLayoutEffect`를 사용했습니다.
    - 빠르게 입력했을 때 깜빡이던 문제가 해결되었습니다. **모든 문제가 해결되어 잘 동작했습니다.**
  - **\[개선\]**
    - (사용자의 입력과 관련된) 상태 업데이트 코드가 change 이벤트 핸들러와 `useLayoutEffect`에 **나뉘어서 작성되어 읽기 힘든 코드라고 판단했습니다.**
    - (span이 value 상태를 자식으로 가지는 대신) change 이벤트 핸들러에서 ref로 직접 span에 접근해 사용자의 마지막 입력값으로 `textContent`를 변경하고, 변경이 반영된 span의 너비를 측정해 input의 너비를 업데이트하는 방식으로 코드를 수정했습니다.
    - 사용자의 입력을 다 표시하지 못하거나 깜빡이는 **문제없이 잘 동작했습니다.**
    - **사용자의 입력이 발생했을 때 수행되어야 할 로직이 change 이벤트 핸들러, 한 곳에만 위치하게 되어 읽기 편한 코드가 되었습니다.**
  - **\[결과\]**
    - 사용자의 입력을 다 표시하지 못하거나, 입력이 깜빡이는 문제를 해결했습니다.
    - 완성된 컴포넌트를 프로젝트 내부의 여러 폼에서 재사용했습니다.

#### 1.2.3 룸 멤버 초대 다이얼로그 개발

**업무**

- 선택한 유저를 초대하는 기능 구현
- 유저, 조직, 룸 이름 기반 검색 기능 구현
- 검색 결과 상태 관리를 위해 MobX Store Class 구조 구상

**성과**

- 검색 결과 화면의 **유저 목록 렌더링 최적화**
  - 화면에 표시되어야 할 유저 아이템만 렌더링하도록 **windowing** 기법을 도입했습니다.
  - `@tanstack/react-virtual` 라이브러리를 활용했습니다.
- 검색 결과 화면의 **무한 스크롤 관련 기획 개선 제안**을 통한 **UX 개선**
  - **\[상황\]**
    - 검색 결과를 "구성원", "조직", "룸" `3` 개의 아코디언으로 묶어서 표현했습니다.
    - 다음 페이지의 "구성원" 정보를 가져오는 동안 사용자가 스크롤을 더 내려서 "조직"이나 "룸"영역으로 이동해버리면, 더 이상 다음 페이지 "구성원" 정보를 가져오지 못했습니다.
    - **스크롤이라는 행위를 통해 다음 페이지 정보를 연속적으로 조회하는, 자연스러운 무한 스크롤 UX를 제공할 수 없었습니다.**
  - **\[과정\]**
    - **기존 기획에서는 `3` 개의 아코디언이 하나의 스크롤 영역을 공유**했고, **다음 페이지 "구성원" 정보 조회를 트리거하는 요소 아래에 "조직", "룸" 아코디언이 존재했습니다.**
    - 다음 페이지의 "구성원" 정보를 가져와 표시하기 전에 스크롤을 아래로 더 내릴 수 있어서, 매끄러운 사용자 경험을 제공하는 무한 스크롤을 만들 수 없었습니다.
    - **기획팀과 소통**하면서, **스크롤 영역을 아코디언 내부로 옮기고 하나의 아코디언만 활성화되도록 제한**하는 아이디어를 제안했습니다.
  - **\[결과\]**
    - 다음 페이지 정보 조회를 트리거하는 요소 아래에 아무것도 위치하지 않아, 데이터를 가져와서 표시하는 동안 더 이상 스크롤 할 수 없게 되었습니다.
    - 스크롤을 통해 연속적으로 다음 페이지 정보를 조회하는, 자연스러운 무한 스크롤 UX를 제공할 수 있게 되었습니다.
    - **기존 기획의 UI를 최대한 유지하면서 사용성을 개선했습니다.**
